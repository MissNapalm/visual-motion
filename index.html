<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: 'unsafe-inline' 'unsafe-eval' blob: data:; media-src * blob: data:; img-src * data: blob:;"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gesture Browser (Electron)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body { height:100%; }
    body { font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif; background:#1a1a1a; color:#111; overflow:hidden; }

    .browser-chrome { background:#f0f0f0; border-bottom:1px solid #ccc; display:flex; flex-direction:column; }
    .window-controls { display:flex; gap:8px; padding:12px; }
    .control { width:12px; height:12px; border-radius:50%; }
    .close{background:#ff5f57}.minimize{background:#ffbd2e}.maximize{background:#28ca42}

    .navigation { display:flex; align-items:center; gap:8px; padding:8px 12px; }
    .nav-btn { width:32px; height:32px; border:none; background:#e0e0e0; border-radius:6px; cursor:pointer; font-size:16px; transition:transform .08s, background .2s; }
    .nav-btn:hover{background:#dcdcdc}.nav-btn:active{transform:scale(.96)}
    .address-bar-container{flex:1}
    .address-bar{width:100%; padding:8px 16px; border:1px solid #ccc; border-radius:20px; font-size:14px; outline:none}
    .address-bar:focus{border-color:#4285f4}

    .browser-content{position:relative; height:calc(100vh - 100px)}
    webview#webview{position:absolute; inset:0; width:100%; height:100%; background:#fff; border:none}

    .camera-overlay{position:fixed; top:100px; right:20px; width:320px; height:240px; background:rgba(0,0,0,.9); border-radius:12px; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,.4); z-index:1000}
    .camera-header{position:absolute; inset:0 0 auto 0; background:rgba(0,0,0,.8); color:#fff; padding:8px 12px; display:flex; justify-content:space-between; align-items:center; font-size:12px; z-index:1001}
    #toggleCamera{background:none; border:none; cursor:pointer; font-size:16px; color:#fff}
    #video{width:100%; height:100%; object-fit:cover; transform:scaleX(-1)}
    #canvas{position:absolute; inset:0; width:100%; height:100%; transform:scaleX(-1)}

    .gesture-indicator{position:fixed; bottom:20px; left:20px; background:rgba(0,0,0,.8); color:#fff; padding:12px 20px; border-radius:8px; font-size:14px; z-index:1200}

    /* Crosshairs (always-on, 2 hands) */
    .crosshair{position:fixed; left:0; top:0; width:28px; height:28px; transform:translate(-50%,-50%); z-index:2000; pointer-events:none; display:none; transition:transform .06s}
    .crosshair.visible{display:block}
    .crosshair .ring{position:absolute; inset:0; border:3px solid var(--ch-color); border-radius:9999px; box-shadow:0 0 18px var(--ch-glow), inset 0 0 6px var(--ch-glow); background:var(--ch-bg)}
    .crosshair .hline,.crosshair .vline{position:absolute; background:var(--ch-color); filter:drop-shadow(0 0 6px var(--ch-glow))}
    .crosshair .hline{left:-14px; right:-14px; top:50%; height:2px; transform:translateY(-50%)}
    .crosshair .vline{top:-14px; bottom:-14px; left:50%; width:2px; transform:translateX(-50%)}
    #crosshair1{--ch-color:#00e5ff; --ch-glow:rgba(0,229,255,.9); --ch-bg:rgba(0,229,255,0.10)}
    #crosshair2{--ch-color:#ff4bd6; --ch-glow:rgba(255,75,214,.9); --ch-bg:rgba(255,75,214,0.10)}
    .crosshair.pinch{transform:translate(-50%,-50%) scale(.85)}
    .crosshair.pulse .ring{animation:chPulse .45s ease-out}
    @keyframes chPulse{0%{transform:scale(1);opacity:1}100%{transform:scale(1.6);opacity:0}}
  </style>
</head>
<body>
  <div class="browser-chrome">
    <div class="window-controls">
      <div class="control close"></div><div class="control minimize"></div><div class="control maximize"></div>
    </div>
    <div class="navigation">
      <button class="nav-btn" id="backBtn" title="Back">‚Üê</button>
      <button class="nav-btn" id="forwardBtn" title="Forward">‚Üí</button>
      <button class="nav-btn" id="reloadBtn" title="Reload">‚Üª</button>
      <div class="address-bar-container"><input id="addressBar" class="address-bar" value="https://www.reddit.com" placeholder="Enter URL..."/></div>
      <button class="nav-btn" id="gestureToggle" title="Toggle Hand Overlay">üé•</button>
    </div>
  </div>

  <div class="browser-content">
    <webview id="webview" src="https://www.reddit.com" allowpopups webpreferences="contextIsolation=yes, nodeIntegration=no"></webview>
  </div>

  <div class="camera-overlay" id="cameraOverlay">
    <div class="camera-header"><span>Hand Tracking</span><button id="toggleCamera">üì∑</button></div>
    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
  </div>

  <div class="gesture-indicator" id="gestureIndicator">Initializing‚Ä¶</div>

  <!-- Always-on dual crosshairs -->
  <div id="crosshair1" class="crosshair"><div class="ring"></div><div class="hline"></div><div class="vline"></div></div>
  <div id="crosshair2" class="crosshair"><div class="ring"></div><div class="hline"></div><div class="vline"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
    const { HAND_CONNECTIONS } = window;

    /* ---------- Pinch detector with smoothing & deadzone ---------- */
    class PinchClick {
      constructor() {
        this.pinchFrames = [0,0];
        this.wasPinching = [false,false];
        this.pinchStart = [{x:0,y:0},{x:0,y:0}];
        this.smooth = [{x:0,y:0},{x:0,y:0}];
        this.lastOut = [{x:0,y:0},{x:0,y:0}];
        this.lastClickAt = 0;
        this.THRESH_FRAMES = 3;      // frames to confirm pinch
        this.DIST_THRESH  = 0.06;    // thumb-index distance for pinch
        this.ALPHA        = 0.35;    // EMA smoothing
        this.DEADZONE_PIX = 6;       // ignore movement smaller than this (viewport px)
        this.COOLDOWN_MS  = 180;     // avoid accidental double clicks
      }
      _dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
      isPinching(lm, idx){
        const pinchNow = this._dist(lm[4], lm[8]) < this.DIST_THRESH;
        this.pinchFrames[idx] = pinchNow ? this.pinchFrames[idx]+1 : 0;
        return this.pinchFrames[idx] >= this.THRESH_FRAMES;
      }
      tip(lm){ return { x: lm[4].x, y: lm[4].y }; }
      ema(idx, cur){ // normalized coords -> smoothed
        const s = this.smooth[idx];
        if (s.x === 0 && s.y === 0) { this.smooth[idx] = {...cur}; return cur; }
        s.x = s.x + this.ALPHA * (cur.x - s.x);
        s.y = s.y + this.ALPHA * (cur.y - s.y);
        return { x:s.x, y:s.y };
      }
      withinDeadzone(idx, pxX, pxY) {
        const p = this.lastOut[idx];
        const dx = pxX - p.x, dy = pxY - p.y;
        return Math.hypot(dx, dy) < this.DEADZONE_PIX;
      }
      rememberOut(idx, pxX, pxY) { this.lastOut[idx] = {x:pxX, y:pxY}; }
      canClick() { return (performance.now() - this.lastClickAt) > this.COOLDOWN_MS; }
      markClicked() { this.lastClickAt = performance.now(); }
    }

    /* ---------- MediaPipe (skeleton overlay only) ---------- */
    class MediaPipeHandler {
      constructor(onResults) {
        this.video = document.getElementById('video');
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.onResultsCallback = onResults;
        this.init();
      }
      async init() {
        try {
          const hands = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
          hands.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
          hands.onResults(r => this.process(r));
          const camera = new Camera(this.video, { onFrame: async () => hands.send({ image:this.video }), width:640, height:480 });
          await camera.start();
          document.getElementById('gestureIndicator').textContent = 'Pinch-to-click + crosshairs enabled';
        } catch (e) { console.error('MediaPipe init error:', e); }
      }
      process(results) {
        this.canvas.width = this.video.videoWidth || 640;
        this.canvas.height = this.video.videoHeight || 480;
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        if (results.multiHandLandmarks?.length) {
          for (const lm of results.multiHandLandmarks) {
            drawConnectors(this.ctx, lm, HAND_CONNECTIONS, { color:'#fff', lineWidth:3 });
            drawLandmarks(this.ctx, lm, { color:'#0f0', lineWidth:2, radius:6 });
          }
        }
        this.onResultsCallback?.(results);
      }
    }

    // ---------- App state ----------
    const webview = document.getElementById('webview');
    const indicator = document.getElementById('gestureIndicator');
    const crosshairEls = [document.getElementById('crosshair1'), document.getElementById('crosshair2')];
    const pinch = new PinchClick();

    // Crosshair helpers
    function showCH(i,x,y){ const el=crosshairEls[i]; el.style.left=x+'px'; el.style.top=y+'px'; el.classList.add('visible'); }
    function moveCH(i,x,y){ const el=crosshairEls[i]; el.style.left=x+'px'; el.style.top=y+'px'; }
    function setCHPinch(i,on){ crosshairEls[i].classList.toggle('pinch', !!on); }
    function pulseCH(i){ const el=crosshairEls[i]; el.classList.remove('pulse'); void el.offsetWidth; el.classList.add('pulse'); }
    function hideCH(i){ crosshairEls[i].classList.remove('visible','pinch','pulse'); }

    // Reliable native click via Electron (reaches iframes like YouTube)
    function nativeClick(vx, vy) {
      // Clamp to viewport
      const rect = webview.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width  - 1, Math.round(vx)));
      const y = Math.max(0, Math.min(rect.height - 1, Math.round(vy)));

      try {
        webview.focus();
        // small pre-move helps some UIs
        webview.sendInputEvent({ type: 'mouseMove', x, y, movementX: 0, movementY: 0 });
        webview.sendInputEvent({ type: 'mouseDown', x, y, button: 'left', clickCount: 1 });
        webview.sendInputEvent({ type: 'mouseUp',   x, y, button: 'left', clickCount: 1 });
        return true;
      } catch (e) {
        console.error('nativeClick failed', e);
        return false;
      }
    }

    // Always-on crosshairs + stabilized pinch-to-click
    function onResults(results) {
      const rect = webview.getBoundingClientRect();
      const hands = results.multiHandLandmarks || [];

      for (let i=0;i<2;i++){
        const lmSrc = hands[i];
        if (!lmSrc) { if (pinch.wasPinching[i]) pulseCH(i); hideCH(i); pinch.wasPinching[i]=false; continue; }

        // Mirror X to match mirrored camera preview
        const lm = lmSrc.map(p => ({...p, x: 1 - p.x}));
        // Smoothed thumb tip
        const rawTip = pinch.tip(lm);
        const tip = pinch.ema(i, rawTip);

        // Map to webview viewport px
        let vx = tip.x * rect.width;
        let vy = tip.y * rect.height;

        // Deadzone to remove micro jitter for crosshair positioning
        if (pinch.withinDeadzone(i, vx, vy)) {
          vx = pinch.lastOut[i].x;
          vy = pinch.lastOut[i].y;
        } else {
          pinch.rememberOut(i, vx, vy);
        }

        const sx = rect.left + vx, sy = rect.top + vy;
        if (!crosshairEls[i].classList.contains('visible')) showCH(i, sx, sy); else moveCH(i, sx, sy);

        // Pinch logic
        const isPinch = pinch.isPinching(lm, i);

        if (isPinch && !pinch.wasPinching[i]) {
          // Pinch start
          pinch.pinchStart[i] = { x: vx/rect.width, y: vy/rect.height }; // store normalized start
          setCHPinch(i, true);
          indicator.textContent = 'Pinching‚Ä¶';
        } else if (!isPinch && pinch.wasPinching[i]) {
          // Pinch release -> click at stored start (stable)
          setCHPinch(i, false);
          pulseCH(i);

          if (pinch.canClick()) {
            pinch.markClicked();
            const clickVx = pinch.pinchStart[i].x * rect.width;
            const clickVy = pinch.pinchStart[i].y * rect.height;
            const ok = nativeClick(clickVx, clickVy);
            indicator.textContent = ok ? 'CLICK!' : 'Click failed';
            setTimeout(() => { indicator.textContent = 'Pinch-to-click + crosshairs enabled'; }, ok ? 400 : 800);
          }
        }

        pinch.wasPinching[i] = isPinch;
      }

      if (!hands.length) { hideCH(0); hideCH(1); indicator.textContent = 'Show hands (crosshairs follow thumbs; pinch to click)'; }
    }

    // Start MediaPipe
    new MediaPipeHandler(onResults);

    // ----- Browser chrome wiring -----
    const addressBar = document.getElementById('addressBar');
    function resolveUrl(v){ v=(v||'').trim(); if(!v) return ''; if(v.startsWith('http://')||v.startsWith('https://')) return v; if(v.endsWith('.html')||v.startsWith('./')||v.startsWith('/')) return v; return 'https://'+v; }
    addressBar.addEventListener('keypress', (e) => { if (e.key==='Enter'){ const url=resolveUrl(e.target.value); if(url) webview.loadURL(url); }});
    document.getElementById('reloadBtn').addEventListener('click', () => webview.reload());
    document.getElementById('backBtn').addEventListener('click', () => webview.canGoBack() && webview.goBack());
    document.getElementById('forwardBtn').addEventListener('click', () => webview.canGoForward() && webview.goForward());
    document.getElementById('toggleCamera').addEventListener('click', () => {
      const overlay=document.getElementById('cameraOverlay');
      overlay.style.display = overlay.style.display==='none' ? 'block' : 'none';
    });
    document.getElementById('gestureToggle').addEventListener('click', () => {
      const overlay=document.getElementById('cameraOverlay');
      overlay.style.display = overlay.style.display==='none' ? 'block' : 'none';
    });

    // Keep address bar synced
    function setAddressBar(url){ addressBar.value = url; }
    webview.addEventListener('did-navigate', (e) => setAddressBar(e.url));
    webview.addEventListener('did-navigate-in-page', (e) => setAddressBar(e.url));
  </script>
</body>
</html>
